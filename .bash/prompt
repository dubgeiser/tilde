#!/usr/bin/env bash

#
# Configure Bash prompt.
# Depends on .bash/colors
#


# GIT prompt configuration
GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUNTRACKEDFILES=1
GIT_PS1_SHOWUPSTREAM="auto"
GIT_PS1_SHOWCOLORHINTS=1


has_virtualenv() {
    if test -n "$VIRTUAL_ENV"; then
        return 0
    fi
    return 1
}


#
# Sourcing virtualenv's ./bin/activate should do this, but this modifies the PS1
# environment variable... which has no effect, due to the standard usage of the
# __git_ps1() function.
#
prompt_fragment_virtualenv() {
    if has_virtualenv; then
        echo "\[${RED}\]\[${REVERSE}\] $(basename "$VIRTUAL_ENV") \[${NORMAL}\] "
    fi
}


#
# The fragment in the prompt at the line the cursor is on.
#
prompt_fragment_cursor_line() {
    if has_virtualenv; then
        prompt_fragment_virtualenv
    else
        echo "\[${REVERSE}\]  \[${NORMAL}\] "
    fi
}


# Thanks @janmoesen for pointing me to the \[\] surrounding the non-printing
# chars.  These are necessary to prevent issues with command line editing,
# -browsing, -completion.
PROMPT_COMMAND='__git_ps1 "\[${REVERSE}\] \w \[${NORMAL}\]" " [\$?]\n$(prompt_fragment_cursor_line)"'
INITIAL_PROMPT_COMMAND=$PROMPT_COMMAND


#
# Simple prompt, mainly without fancy coloring and without git info.
# Useful when in a big directory: if you'd leave the git part on, the prompt
# will take _seconds_ before it appears.
#
prompt_simple() {
    PROMPT_COMMAND='PS1="\[${REVERSE}\] \w \[${NORMAL}\] [\$?]\n"'
}


#
# Restore the prompt back to its initial state.
#
prompt_restore() {
    PROMPT_COMMAND=$INITIAL_PROMPT_COMMAND
}
